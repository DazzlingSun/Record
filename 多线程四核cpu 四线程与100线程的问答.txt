100任务，假设每个任务执行时间平均为2s，我的机器cpu核数为4。那么线程池大小100个快，还是4个快？ 我跑出来的结果是：
100个线程执行 100个任务, 耗时 : 5063ms
4个线程执行 100个任务, 耗时 : 50042ms

为什么哪:smiley:

赞  回复
 @黑色幽默_cool 线程调度的问题
2018.04.19 11:30  回复
 @黑色幽默_cool 还有你这个两秒是实际的计算任务还是什么？有没有io等待？有没有线程睡眠？
2018.04.19 11:32  回复
 @虾游于海 hi 我这2s是满负荷工作，也就是阻塞一直占用cpu直到任务结束，中间没出现睡眠的情况、
2018.04.19 13:13  回复
 @黑色幽默_cool 不一样，线程阻塞并不会导致cpu满负荷，不是一个概念！
2018.04.19 15:24  回复
 @虾游于海 我的任务
long start = System.currentTimeMillis();
while (true) {
if(System.currentTimeMillis() - start > 2000) {
break;
}
System.err.println(" === I am working on something, not finished yet, i need the cpu to print ==== ");
}
2018.04.19 16:43  回复
 @黑色幽默_cool 
你这个肯定了呀。
你这个是个判断量，不是计算量。差别大着呢。
2018.04.19 16:47  回复
 @黑色幽默_cool 
long count = 0;
while (true) {
count++;
if (count > 10000000L) {
break;
}
}

你换成这个
2018.04.19 17:02  回复
 @虾游于海 哈哈 还是大佬理解的透彻啊！！！
100线程--5次测试时间-->215ms 201ms 191ms 224ms 240ms
4线程--5次测试时间-->190ms 193ms 217ms 188ms 225ms

4线程的应该是略快的，那么问题来了，请教请教请教~~
我给的例子，每个线程一直占用着cpu，也没闲着，一直在打印数据，一直到2s停掉~
您给的这个例子，一直在做计算，达到if那个判断阀值，再停掉
为啥子嘞？
2018.04.19 17:11  回复
 @黑色幽默_cool 你那个线程启动，计录的是时间，100个线程启动的时间点是差不多一致的，虽然刚开始是占用的，但只要某个线程结束了，其它线程的再检查时间也就到了！但如是4线程，会等待上个任务完成后再启动！所以是不一样的！还有就是操作系统不会让cpu真的被某个cpu完全占用的！
2018.04.19 17:48  回复
 @虾游于海 秒懂 多谢~
2018.04.19 18:43  回复
 @黑色幽默_cool 在设定线程池大小时，您有什么建议？:+1:
2018.04.19 19:01  回复
 @黑色幽默_cool 这个东西要看你能不能处理好阻塞和cpu计算的关系了，如果能处理好的话，线程池的数目应该最大等于CPU的核心数，但如果你线程里面有IO阻塞的话，就不能这么分了。这也是一些响应式框架产生的原因！这个没有一个定数的！
2018.04.19 19:43  回复
 @虾游于海 那么当有IO操作的时候，线程的数目应该要适当多一点。可以根据IO操作的阻塞时间占总执行时间的比例，先给一个预估值？然后慢慢调整？
2019.02.24 15:21  回复
 @小慎 我一般是这个套路，其实吧！知道原理之后就是测试了！知道线程池不是越多越好，也不是越少越好之后，就慢慢试！
2019.02.25 08:26  回复